function varargout = AnalyzeFreeSwims_nCycles(varargin)
%AnalyzeFreeSwims Given procData.mat generated by SlowSwim, returns some
%   useful info after analyzing swims
% out = AnalyzeFreeSwims();
% out = AnalyzeFreeSwims(procData,'fps',fps,'nFramesInTrl',nFramesInTrl,'paramList', paramList);
% out = AnalyzeFreeSwim([],'fps',fps,...);
% Inputs:
% procData - Processed data .mat file created by SlowSwim.m and/or related
%   scripts
% 'fps'  - Frames per second (default: 500)
% 'nFramesInTrl' - Number frames in a single trial (default: 750)
% 'paramList' - List of params to extract in this function (default:
%   {'bodyAmp', 'bodyPer', 'headAmp'}).
%   'bodyAmp' - Total body bending amplitudes
%   'angVel' - Period for total body bends
%   'headAmp' - Amplitudes for only head segment bends
% 
% Avinash Pujala, Koyama lab/HHMI, 2016

fps = 500;
nFramesInTrl = 750;
preStimPeriod = 0.1;
xLim = [0 0.8*1000];  % For vibration
% xLim = [0 1.5*1000]; % For dark flash
stringency = 1.5;
paramList_all = {'bodyAmp','angVel','headAmp'};
paramList = paramList_all;

% cd('S:\Avinash\Ablations and behavior\Intermediate RS\20160715')
if nargin ==0
    [fileName,pathName] = uigetfile('*.mat');
    procData = matfile(fullfile(pathName,fileName));
elseif nargin == 1
    procData = varargin{1};
    if isempty(procData)
        [fileName,pathName] = uigetfile('*.mat');
        procData = matfile(fullfile(pathName,fileName));
    end
    fNames = fieldnames(procData);
    if  any(strcmpi(fNames,'fps'))
        fps = procData.fps;
    end
    if any(strcmpi(fNames,'nFramesInTrl'))
        nFramesInTrl = procData.nFramesInTrl;
    end
else
    procData = varargin{1};
    if isempty(procData)
        [fileName,pathName] = uigetfile('*.mat');
        procData = matfile(fullfile(pathName,fileName));
    end
    for jj = 1:numel(varargin)
        if ischar(varargin{jj})
            switch lower(varargin{jj})
                case 'fps'
                    fps = varargin{jj+1};
                case lower('nFramesInTrl')
                    nFramesInTrl = varargin{jj+1};
                case lower('preStimPeriod')
                    preStimPeriod = varargin{jj+1};
                case lower('paramList')
                    paramList = varargin{jj+1};
                case lower('xLim')
                    xLim = varargin{jj+1};
            end
        end
    end
end

cd(pathName)
if ~iscell(paramList)
    paramList ={paramList};
end

paramInds = zeros(length(paramList),1);
for jj = 1:length(paramList)   
    ind = find(strcmpi(paramList_all,paramList{jj}));
    paramInds(jj) = ind;
end

disp('Reading data from procData...')
tic
disp('Tail curvature...')
tailCurv = procData.tailCurv;
procData.Properties.Writable = true;
toc

time = (0:size(tailCurv,3)-1)*(1/fps);
nTrls = length(time)/nFramesInTrl;

tA_5 = GetTailTangents(tailCurv,5);
curv = tA_5(end,:)';
curv_head = tA_5(1,:)';
tA_trl = reshape(curv,nFramesInTrl,nTrls);
tA_trl_head = reshape(curv_head,nFramesInTrl,nTrls);
time_trl = time(1:nFramesInTrl);
pkThr1 = stringency*std(tA_trl(:));
pkThr3 = stringency*std(tA_trl_head(:));
maxFreq = 60;
minIntPts = ceil((0.5/maxFreq)*fps);

blah = chebfilt(tA_trl,1/fps,30,'low');
dTrace_all = gradient(blah')';
pkThr2 = stringency*std(dTrace_all(:));

out = struct;
figure('Name','Pk info')
out.bendAmp = cell(nTrls,1);
out.bendPer = out.bendAmp;
out.onset = zeros(nTrls,1);
out.bendAngVel = out.bendAmp;
for trl = 1:nTrls
    tr = tA_trl(:,trl);
    tr_head = tA_trl_head(:,trl);
    pks1 = GetPks(tr,'polarity',0, 'peakThr',pkThr1,'thrType','rel','minPkDist',minIntPts);
    mT = max(abs(tr));
    dTrace = dTrace_all(:,trl);
    pks2 = GetPks(dTrace,'polarity',0, 'peakThr',pkThr2,'thrType','rel','minPkDist',minIntPts);
    pks3 = GetPks(tr_head,'polarity',0, 'peakThr',pkThr3,'thrType','rel','minPkDist',minIntPts);
    mDT = max(dTrace);
    sf = 0.5*mT/mDT;
    x_trace1 = 0;
    for traceType = paramInds(:)'
        cla
        maxY = max(tA_trl(:,trl));
        minY = min(tA_trl(:,trl));
        if traceType ==1
            plot(time_trl*1000,tr)
            hold on
            plot(time_trl(pks1)*1000,tr(pks1),'ko')
            plot(time_trl*1000,dTrace*sf,'r:')
            ylim([min([minY,-250]) max([maxY,250])])           
        elseif traceType ==2
            plot(time_trl*1000,tr,'b:')
            hold on
            plot(time_trl*1000,dTrace*sf,'r')
            plot(time_trl(pks2)*1000,dTrace(pks2)*sf,'ko')
            ylim([min([minY,-250]) max([maxY,250])])
            
        else
            cla
            plot(time_trl*1000,tr_head)
            hold on
            plot(time_trl(pks3)*1000,tr_head(pks3),'ro')
            ylim([min([minY,-100]) max([maxY,100])])
        end
        ylabel(paramList_all{traceType})
        
        box off
        xlim(xLim)
        set(gca,'xtick',[100 500 1000 15000])
        title(['Click on 5 pts to get onset, 1st and 3rd undulation info, Trl # ' num2str(trl)])
        shg
        [x,y,~] = ginput_plot();
        if ~isempty(x) && traceType ==1
            x_trace1 = x;
            preInds = find((time_trl(pks1)*1000) < min(x));
            postInds = find((time_trl(pks1)*1000) > max(x));
            prePostInds = union(preInds,postInds);
            pks1(prePostInds)=[];
            time_trl = time_trl(:);
            tr = tr(:);
            x = [x(:);time_trl(pks1)*1000];
            y = [y(:); tr(pks1)];
            [x,inds] = sort(x);
            y = y(inds);
            dx = (diff(x)/1000)*fps;
            inds = find(dx < minIntPts);
            x(inds) = [];
            y(inds)=[];
            for bend = 2:numel(x)
                out.bendAmp{trl}(bend-1) = y(bend)-y(bend-1);
                out.bendPer{trl}(bend-1) = x(bend)-x(bend-1);
            end
            out.onset(trl) = x(1)-(preStimPeriod*1000);
        elseif ~isempty(x) && traceType ==2
            [~, inds] = sort(x);
            y = y(inds);
            preInds = find((time_trl(pks2)*1000) < min(x_trace1));
            postInds = find((time_trl(pks2)*1000) > max(x_trace1));
            prePostInds = union(preInds,postInds);
            pks2(prePostInds)=[];
            time_trl = time_trl(:);
            dTrace = dTrace(:);
            x = [x(:);time_trl(pks2)*1000];
            y = [y(:); dTrace(pks2)];
            [x,inds] = sort(x);
            y = y(inds);
            dx = (diff(x)/1000)*fps;
            inds = find(dx < minIntPts);
            x(inds) = [];
            y(inds)=[];
            for bend = 1:numel(x)
                out.bendAngVel{trl}(bend) = y(bend)/sf;
            end
        elseif ~isempty(x) && traceType ==3
            x_trace1 = x;
            preInds = find((time_trl(pks3)*1000) < min(x));
            postInds = find((time_trl(pks3)*1000) > max(x));
            prePostInds = union(preInds,postInds);
            pks3(prePostInds)=[];
            time_trl = time_trl(:);
            tr = tr(:);
            x = [x(:);time_trl(pks3)*1000];
            y = [y(:); tr_head(pks3)];
            [x,inds] = sort(x);
            y = y(inds);
            dx = (diff(x)/1000)*fps;
            inds = find(dx < minIntPts);
            x(inds) = [];
            y(inds)=[];
            for bend = 2:numel(x)
                out.headAmp{trl}(bend-1) = y(bend)-y(bend-1);
                out.headPer{trl}(bend-1) = x(bend)-x(bend-1);
            end
        else
            for bend = 1:numel(x)
                out.bendAngVel{trl}(bend) = y(bend)/sf;
            end
        end
    end
    
end

saveOrNot = input('Append pk data to procData? (y/n)','s');
if strcmpi(saveOrNot,'y')
    procData.Properties.Writable = true;
    procData.elicitedSwimInfo = out;
end

varargout{1} = out;
varargout{2} = procData;
end

