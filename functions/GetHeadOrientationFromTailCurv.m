function varargout = GetHeadOrientationFromTailCurv(tailCurv,varargin)
%GetHeadOrientationFromTailCurv Given the 3 dimensional tailCurv variable
%   generated by SlowSwim.m and related scripts, along with some optional
%   variables, returns the absolute head orientation of the fish.
% headOrientation = GetHeadOrientationFromTailCurv(tailCurv);
% [headOrientation, headOrientation_fit] =
%   GetHeadOrienationFromTailCurv(tailCurv,lenOfHeadSeg);
% Inputs:
% tailCurv - 3D matrix generated by SlowSwim and related scripts, where 1st
%   dim is rostrocaudal position along the body, 2nd dim are the x, and y
%   coordinates of this position, and the 3rd dim is frame #.
% lenOfHeadSeg - Length of head segment to use for estimating head
%   orientation
% Outputs:
% headOrientation - Head orientation vector obtained using the difference
%   vector at each time point for the last point and the first point of the
%   head segment
% headOrientation_fit - Head orientation obtained by fitting line to head
%   segment points
% Avinash Pujala, Koyama lab/HHMI

lenOfHeadSeg = 5;
theta = @(v1,v2) acos(dot(v1,v2)/(norm(v1)*norm(v2)))* pi/180;
Complexify = @(v) v(1) + v(2)*1i;
if nargin == 2
    lenOfHeadSeg = varargin{1};
    lenOfHeadSeg = min(lenOfHeadSeg, size(tailCurv,1));
end

nTimePts = size(tailCurv,3);
hOr = zeros(nTimePts,1);
hOr_fit = hOr;
v_1 =  [tailCurv(lenOfHeadSeg,1,1),tailCurv(lenOfHeadSeg,2,1)] - [tailCurv(1,1,1),tailCurv(1,2,1)];
v_1_fit = FitLine(tailCurv(1:lenOfHeadSeg,:,1));
v_1_fit = v_1_fit(end,:)- v_1_fit(1,:);
hOr(1) = angle(Complexify(v_1))*180/pi;
hOr_fit(1) = angle(Complexify(v_1_fit))*180/pi;

for tt = 2:nTimePts
    if tt ~=2
        v_1 = [tailCurv(lenOfHeadSeg,1,tt-1),tailCurv(lenOfHeadSeg,2,tt-1)] - [tailCurv(1,1,tt-1),tailCurv(1,2,tt-1)];
        v_1_fit = FitLine(tailCurv(1:lenOfHeadSeg,:,tt));
        v_1_fit = v_1_fit(end,:)- v_1_fit(1,:);
    end
    v_2 = [tailCurv(lenOfHeadSeg,1,tt),tailCurv(lenOfHeadSeg,2,tt)] - [tailCurv(1,1,tt),tailCurv(1,2,tt)];
    hOr(tt) = angle(Complexify(v_1) * conj(Complexify(v_2)))*180/pi;
    if nargout ==2
        v_2_fit = FitLine(tailCurv(1:lenOfHeadSeg,:,tt-1));
        v_2_fit = v_2_fit(end,:)- v_2_fit(1,:);
        hOr_fit(tt) = angle(Complexify(v_1_fit)*conj(Complexify(v_2_fit)))*180/pi;
    end
end
hOr(hOr>90) = mod(hOr(hOr>90),90);
hOr(hOr<-90) = mod(hOr(hOr<-90),-90);

hOr_fit(hOr_fit>90) = mod(hOr_fit(hOr_fit>90),90);
hOr_fit(hOr_fit<-90) = mod(hOr_fit(hOr_fit<-90),-90);

hOr(isnan(hOr))=0; % Because tailCurv can have NaNs for frames where tail-tracking fails.
hOr_fit(isnan(hOr_fit))=0;

hOr = cumsum(hOr);
hOr_fit = cumsum(hOr_fit);

varargout{1} = hOr;
varargout{2} = hOr_fit;

    function fit_line = FitLine(xyCoords)
        %         X = [ones(size(xyCoords,1),1),xyCoords(:,1)];
        %         B = X\xyCoords(:,2);
        %         fit_line = B(1) + B(2)*X(:,2);
        B = polyfit(xyCoords(:,1),xyCoords(:,2),1);
        fit_line = B(2) + B(1)*xyCoords(:,1);
        fit_line = [xyCoords(:,1) fit_line(:)];
    end


end

