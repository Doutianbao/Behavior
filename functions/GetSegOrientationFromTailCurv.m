function varargout = GetSegOrientationFromTailCurv(tailCurv,varargin)
%GetSegOrientationFromTailCurv Given the 3 dimensional tailCurv variable
%   generated by SlowSwim.m and related scripts, along with some optional
%   variables, returns the absolute orientation of a specified segment the fish
%   along the rostrocaudal axis.
% headOrientation = GetHeadOrientationFromTailCurv(tailCurv);
% [segOrientation, segOrientation_fit] =
%   GetHeadOrienationFromTailCurv(tailCurv,segRange);
% Inputs:
% tailCurv - 3D matrix generated by SlowSwim and related scripts, where 1st
%   dim is rostrocaudal position along the body, 2nd dim are the x, and y
%   coordinates of this position, and the 3rd dim is frame #.
% segRange - Range of the segment for which to find the orientation
%   specified as percent of total body length. For instance,
%   segRange = [40 60], selects a segemnt that is between the 40th and 60th
%   percent mark along the tailCurv. Default = [10, 60] (for detecting head orientation)
% Outputs:
% headOrientation - Head orientation vector obtained using the difference
%   vector at each time point for the last point and the first point of the
%   head segment
% headOrientation_fit - Head orientation obtained by fitting line to head
%   segment points
% Avinash Pujala, Koyama lab/HHMI

segRange = [0, 25];
% theta = @(v1,v2) acos(dot(v1,v2)/(norm(v1)*norm(v2)))* pi/180;
Complexify = @(v) v(1) + v(2)*1i;
if nargin == 2   
    segRange = varargin{1};
    if numel(segRange) < 2
        error('Input for segment range must contain 2 values!')       
    end
    segRange = sort(segRange,'ascend');
    segRange(1) = max(segRange(1),0); % Values can only be from 0 to 100
    segRange(2) = min(segRange(2),100);
end

bodyLen = size(tailCurv,1);
nTimePts = size(tailCurv,3);
segOr = zeros(nTimePts,1);
segOr_fit = segOr;
segRange = (segRange/100);
segStartInd = max(ceil(segRange(1)*bodyLen),1);
segEndInd = min(floor(segRange(2)*bodyLen),bodyLen);
v_1 =  [tailCurv(segEndInd,1,1),tailCurv(segEndInd,2,1)] - ...
    [tailCurv(segStartInd,1,1),tailCurv(segEndInd,2,1)];
v_1_fit = FitLine(tailCurv(segStartInd:segEndInd,:,1));
v_1_fit = v_1_fit(end,:)- v_1_fit(1,:);
segOr(1) = angle(Complexify(v_1))*180/pi;
segOr_fit(1) = angle(Complexify(v_1_fit))*180/pi;

for tt = 2:nTimePts
    if tt ~=2
        v_1 = [tailCurv(segEndInd,1,tt-1),tailCurv(segEndInd,2,tt-1)] - ...
            [tailCurv(segStartInd,1,tt-1),tailCurv(segStartInd,2,tt-1)];
        v_1_fit = FitLine(tailCurv(segStartInd:segEndInd,:,tt));
        v_1_fit = v_1_fit(end,:)- v_1_fit(1,:);
    end
    v_2 = [tailCurv(segEndInd,1,tt),tailCurv(segEndInd,2,tt)] - ...
        [tailCurv(segStartInd,1,tt),tailCurv(segStartInd,2,tt)];
    segOr(tt) = angle(Complexify(v_1) * conj(Complexify(v_2)))*180/pi;
    if nargout ==2
        v_2_fit = FitLine(tailCurv(1:segRange,:,tt-1));
        v_2_fit = v_2_fit(end,:)- v_2_fit(1,:);
        segOr_fit(tt) = angle(Complexify(v_1_fit)*conj(Complexify(v_2_fit)))*180/pi;
    end
end
segOr(segOr>90) = mod(segOr(segOr>90),90);
segOr(segOr<-90) = mod(segOr(segOr<-90),-90);

segOr_fit(segOr_fit>90) = mod(segOr_fit(segOr_fit>90),90);
segOr_fit(segOr_fit<-90) = mod(segOr_fit(segOr_fit<-90),-90);

segOr(isnan(segOr))=0; % Because tailCurv can have NaNs for frames where tail-tracking fails.
segOr_fit(isnan(segOr_fit))=0;

segOr = cumsum(segOr);
segOr_fit = cumsum(segOr_fit);

varargout{1} = segOr;
varargout{2} = segOr_fit;

    function fit_line = FitLine(xyCoords)
        %         X = [ones(size(xyCoords,1),1),xyCoords(:,1)];
        %         B = X\xyCoords(:,2);
        %         fit_line = B(1) + B(2)*X(:,2);
        B = polyfit(xyCoords(:,1),xyCoords(:,2),1);
        fit_line = B(2) + B(1)*xyCoords(:,1);
        fit_line = [xyCoords(:,1) fit_line(:)];
    end


end

