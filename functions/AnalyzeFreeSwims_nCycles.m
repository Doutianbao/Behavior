function varargout = AnalyzeFreeSwims_nCycles(varargin)
%AnalyzeFreeSwims Given procData.mat generated by SlowSwim, returns some
%   useful info after analyzing swims
% out = AnalyzeFreeSwims();
% out = AnalyzeFreeSwims(procData,'fps',fps,'nFramesInTrl',nFramesInTrl);
%
% Avinash Pujala, Koyama lab/HHMI, 2016

fps = 500;
nFramesInTrl = 750;
preStimPeriod = 0.1;

if nargin ==0
    cd('S:\Avinash\Ablations and behavior\Intermediate RS\20160715')
    [fileName,pathName] = uigetfile('*.mat');
    procData = matfile(fullfile(pathName,fileName));
elseif nargin ==1
    procData = varargin{1};
    fNames = fieldnames(procData);
    if  any(strcmpi(fNames,'fps'))
        fps = procData.fps;
    end
    if any(strcmpi(fNames,'nFramesInTrl'))
        nFramesInTrl = procData.nFramesInTrl;
    end
else
    for jj = 1:numel(varargin)
        if ischar(varargin{jj})
            switch lower(varargin{jj})
                case 'fps'
                    fps = varargin{jj+1};
                case lower('nFramesInTrl')
                    nFramesInTrl = varargin{jj+1};
                case lower('preStimPeriod')
                    preStimPeriod = varargin{jj+1};
            end
        end
    end
end

disp('Reading data from procData...')
tic
disp('Tail curvature...')
tailCurv = procData.tailCurv;

toc
try
    imgDims = procData.imgDims_crop;
catch
    disp('Extracting image dimensions...')
    imgDims = size(procData.IM_proc_crop);
    procData.Properties.Writable = true;
    procData.imgDims_crop = imgDims;
end

imgDims = imgDims(1:2);
disp('Calculating tail angles...')
tAngles = GetTailTangents(tailCurv);
toc
time = (0:size(tailCurv,3)-1)*(1/fps);
nTrls = length(time)/nFramesInTrl;

tA_5 = GetTailTangents(tailCurv,5);
curv = tA_5(end,:)';
tA_trl = reshape(curv,nFramesInTrl,nTrls);
time_trl = time(1:nFramesInTrl);


out = struct;
figure('Name','Pk info')
for trl = 1:nTrls    
    trace = tA_trl(:,trl);
        mT = max(abs(trace));
        dTrace = gradient(chebfilt(trace,1/fps,20,'low'));
        mDT = max(dTrace);
        sf = 0.5*mT/mDT;
    for traceType = 1:2  
        cla
        if traceType ==1
            plot(time_trl*1000,trace)
            hold on
            plot(time_trl*1000,dTrace*sf,'r:')
        else            
            plot(time_trl*1000,trace,'b:')
            hold on
            plot(time_trl*1000,dTrace*sf,'r')
        end
        maxY = max(tA_trl(:,trl));
        minY = min(tA_trl(:,trl));
        box off
        %     xlim([-inf (nFramesInTrl/fps)*1000])
        xlim([-inf 1.5*1000])
        ylim([min([minY,-250]) max([maxY,250])])
        set(gca,'xtick',[100 500 1000 15000])
        title(['Click on 5 pts to get onset, 1st and 3rd undulation info, Trl # ' num2str(trl)])
        shg
        [x,y,button] = ginput_plot();
        
        if ~isempty(x) && traceType ==1
            for bend = 2:numel(x)
                out.bendAmp{trl}(bend-1) = y(bend)-y(bend-1);
                out.bendPer{trl}(bend-1) = x(bend)-x(bend-1);
            end
            out.onset(trl) = x(1)-(preStimPeriod*1000);
        else
            for bend = 1:numel(x)
                out.bendAngVel{trl}(bend) = y(bend)/sf;
            end
        end
    end
    %     evens = 2:2:numel(x);
    %     if ~isempty(evens) && (evens(end)== numel(x));
    %         x(end) = [];
    %         evens = 2:2:numel(x);
    %     end
    %     if all(button==1) && ~isempty(button)
    %         for cyc = 1:numel(evens)
    %             ind = evens(cyc);
    %             out.pk{trl}(cyc) =y(ind)-y(ind-1);
    %             out.per{trl}(cyc) = x(ind+1)-x(ind-1);
    %         end
    %         out.onset(trl) = x(1)-(preStimPeriod)*1000;
    %     else
    %         out.onset(trl) = nan;
    %         out.pk{trl} = nan;
    %         out.per{trl} = nan;
    %     end
    
end
% out.onset_mean = mean(out.onset(~isnan(out.onset)));
% out.onset_std = std(out.onset(~isnan(out.onset)));
% out.one.amp_mean = mean(abs(out.one.amp(~isnan(out.one.amp))));
% out.one.amp_std  = std(abs(out.one.amp(~isnan(out.one.amp))));
% out.one.per_mean = mean(out.one.per(~isnan(out.one.per)));
% out.one.per_std =  std(out.one.per(~isnan(out.one.per)));
% out.three.amp_mean = mean(abs(out.three.amp(~isnan(out.three.amp))));
% out.three.amp_std = std(abs(out.three.amp(~isnan(out.three.amp))));
% out.three.per_mean = mean(out.three.per(~isnan(out.three.per)));
% out.three.per_std = std(out.three.per(~isnan(out.three.per)));

saveOrNot = input('Append pk data to procData? (y/n)','s');
if strcmpi(saveOrNot,'y')
    procData.Properties.Writable = true;
    procData.elicitedSwimInfo = out;
end

varargout{1} = out;
varargout{2} = procData;
end

