function tailCurv = SmoothenMidlines(midlineInds,imgStack, varargin)
%SmoothMidlines - Given midline indices generated get GetMidlines.m and the
%   stack of images from whence these indices arise, returns smoothed tail
%   curves (head segment omitted) a la Huang et al, 2013.
%
% tailCurv = SmoothMidlines(midlineInds,imgStack);
% tailCurv = SmoothMidlines(midlineInds,imgStack,nHood);
% tailCurv = SmoothMidlines(midlineInds,imgStack,nHood,'plotBool', plotBool,)
% Inputs:
% midlineInds - Midline segments as generated by GetMidlines.m
% imgStack - Stack of images to which the midline indices correspond
% nHood - Size of local pixel neighborhood used to smooth zig-zag tail
%   curves resulting from integer coordinates of midlineInds. Default = 1.
%
% Reference:
% Huang, K.-H., Ahrens, M.B., Dunn, T.W., and Engert, F. (2013). Spinal Projection
%   Neurons Control Turning Behaviors in Zebrafish. Current Biology 23, 1566–1573.
%
% Avinash Pujala, Koyama lab/HHMI, 2016

nHood = 2; % Default neighborhood size
plotBool = false;
pauseDur = 0;
smoothFactor = 2;

if nargin < 2
    error('Minimum 2 inputs required!')
elseif nargin > 2
    if ~ischar(varargin{1})
        nHood = varargin{1};
    end
end
for jj = 1:numel(varargin)
    if ischar(varargin{jj})
        switch lower(varargin{jj})
            case 'plotbool'
                plotBool = varargin{jj+1};
            case 'pausedur'
                pauseDur = varargin{jj+1};
            case 'smoothfactor'
                smoothFactor = varargin{jj+1};
        end
    end
end
if length(midlineInds) ~= size(imgStack,3)
    error('Mismatch in size of inputs, check inputs!')
end

imgStack = Standardize(imgStack); % Important for smoothing midlines using pxl intensity weighting (avoids -ve values)
bodyLen = size(cell2mat(midlineInds{1}),1);
tailLen = bodyLen -length(midlineInds{1}{1});
tailCurv = zeros(tailLen,2,length(midlineInds));
dispChunk = round(length(midlineInds)/5);
disp('Smoothing midlines...')
if plotBool
    figure('Name','Smoothed fish tail curvature')
end
tic
N = length(midlineInds);
for iNum = 1:N
    mlInds = midlineInds{iNum};
    if length(mlInds)>1
        mlInds = cell2mat(mlInds(2:end));
    else
        mlInds= cell2mat(mlInds(1));
    end    
    tc = SmoothenMidline(mlInds,imgStack(:,:,iNum),nHood);
    tailCurv(:,:,iNum) = SplineTailCurv(tc,smoothFactor);
    if mod(iNum,dispChunk)==0
        disp(['Img # ' num2str(iNum) '/' num2str(N)])
    end
    if plotBool
        cla
        imagesc(imgStack(:,:,iNum)),axis image, colormap(gray)
        hold on
        plot(size(imgStack,1)/2+1,size(imgStack,2)/2+1,'b*','markersize',10)
        plot(tailCurv(:,1,iNum), tailCurv(:,2,iNum),'r.-','linewidth',2.5)
        %         plot(tc(:,1),tc(:,2),'g.-')
        drawnow
        title(['Img # ' num2str(iNum)])
        shg
        if isempty(pauseDur)
            pause()
        else
            pause(pauseDur)
        end
    end
end
toc

end


function tailCurv = SmoothenMidline(mlInds,img,nHood)
tailCurv = zeros(length(mlInds),2);
[r,c] = ind2sub(size(img),mlInds);
[C,R] = meshgrid(1:size(img,2),1:size(img,1));
for jj = 1:size(r,1)
    rInds = r(jj)-nHood:r(jj)+nHood;
    rInds(rInds<=0)=[];
    cInds = c(jj)-nHood:c(jj)+nHood;
    cInds(cInds<=0)=[];
    rNeighbors = R(rInds,cInds);
    cNeighbors = C(rInds,cInds);
    wts = img(rInds,cInds);
%     ker = ones(length(wts));
%     wts = conv2(wts,ker,'same');
    pxlInd(1) = sum(rNeighbors(:).*wts(:))/sum(wts(:));
    pxlInd(2) = sum(cNeighbors(:).*wts(:))/sum(wts(:));
    tailCurv(jj,:)= fliplr(round(pxlInd*10)/10); % Flipping to give in x-y rather than row-col coordinates
end
end


function tailCurv_spline = SplineTailCurv(tailCurv,smoothFactor)
% y = [tailCurv(1,:); tailCurv; tailCurv(end,:)];
y = tailCurv;
t = 1:size(y,1);
ts = linspace(1,size(y,1),size(y,1)/smoothFactor);
ys(:,1) = spline(t,y(:,1),ts);
ys(:,2) = spline(t,y(:,2),ts);
y(:,1) = spline(ts,ys(:,1),t);
y(:,2) = spline(ts,ys(:,2),t);
tailCurv_spline = y;
% tailCurv_spline = [xx(2:end-1); yy(2:end-1)]';

end